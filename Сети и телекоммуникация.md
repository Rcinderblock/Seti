# Три метода передачи даннных:
1. Симплексный — передача строго в одном направлении (радиовещание, телевидение)
2. Полудуплексный — передача в оба направления попеременно (рация)
3. (Полный) дуплекс — передача в оба направления одновременно
Данные передаются посредством протоколов.
# Протокол
Протокол — соглашение между интерфейсами логического уровня. Например, русский язык (есть сговоренность об алфавите, словарном запасе). То есть протокол — правила передачи информации.
Протоколы делятся по типу установления соединения:
- С установлением соединения (Покой -> соединение (запрос на соединение) -> передача (с получением обратной связи) -> разрыв (чтобы освободить получателя) -> покой). Надежная передача.
- Без установления соединения (Покой -> передача (как только появляются данные для передачи, не проверяя доходят ли данные) -> покой). Ненадежная передача, real-time передача.
Теорема Котельникова рассказывает о способе передачи сигнала дискретно, т.е. как разбить аналоговый сигнал на отчеты. Иными словами, как часто брать моментальные передачи сигнала (отчеты), которые должны передаваться без задержки времени (иначе будет задерживание в real-time).

Второй вариант классификации протоколов:
 - Байт-ориентированные протоколы. Направляющая комбинация байт-протоколов говорит о начале и окончании передачи. Может произойти проблема: придет байт, который похож на завершающий байт. Для борьбы с этим есть два варианта: 1) разделить реализацию на прозрачную и непрозрачную передачи данных. В непрозрачной реализации данные не могут быть похожи на управляющая комбинация. Прозрачная передача говорит об обратном, однако в ситуации коллизии борется сам протокол. Три варианта борьбы: 
 1) Byte-stuffing: добавляем в байты мусорные данные, например [STR]ababbaababENDbababa[END] -> [STR]ababbaababZZZENDbababa[END]. Этот байт вставляет источник данных, а не получатель, поэтому получается вставить там где нужно.
 2) Bit-stuffing: допустим управляющая комбинация выглядит как 01111110 -> 011111010, тогда получатель удаляет нолик, который видит через пять единиц подряд. Таким образом, если получатель видит 5 единиц подряд, то мы должны сообщить ему что это не окончание с помощью нуля.
 3) Сделать управляющую комбинацию уникальной. То есть с очень малой долой вероятности данные будут походить на управляющую комбинацию (с помощью физического кодирования)
 - Бит-ориентированные протоколы. Местоположение бита определяет его функционал. Например, если 7 бит в 3 байте единица, то текст внутри пакета красного текста.

# Какие бывают сети?
- Глобальные (WAN - Wide Area Net). Весь интернет, все сети, т.е. совокупность (соединение) локальных сетей.
- Локальные (LAN - Local Area Net). До нескольких километров
Еще есть MAN (Городская вычислительная сеть, Metropolitan Area Net) -- между LAN и WAN
# Топология сети
Топология сети -- способ организации связи между устройствами, т.е. граф, вершина которого -- сетевые устройства, а ребра -- каналы связи.
Топологии делятся на физические (провода, кабели) и логические (способ передачи данных).
Есть 5 основных топологий сети, остальные являются их производными:
- Шина |---PC-----PC------PC----|; Смысл шины заключается в том, что все устройства подсоединены к одной среде передачи данных. Это самая первая топология. Проблема шины в том, что разные устройства передают разную информацию разным устройствам и данные загрязняются друг другом. Если порвать шину где-нибудь в середине, то связь работать не будет. По краям стоят терминаторы, которые гасят сигнал.
- Кольцо ![[Pasted image 20250214153052.png]]
Достоинства: 1) Передача идет в одном направлении и каждая дуга -- отдельный провод, то есть у каждого компьютера свой провод, никто никому не мешает. 2) За счет свойств кольца, вы будете получать фидбек в любом случае, даже если протоколы без установки соединений. Минусы: 1) если где-то порвется связь, то остановится всё.
- Звезда -- самая распространенная топология на данный момент.![[Pasted image 20250214153629.png]]
Если центральный узел падает, падает все. Однако если упадет одно поддерево, то отрежется только оно, а не все. Для компьютеров в 805 аудитории центральный узел -- коммутатор. У этого коммутатора если коммутатор-отец, у которого еще дети-коммутаторы в разных аудиториях. Центральный узел -- не компьютер, а маршрутизатор или коммутатор.
- Полносвязная топология.![[Pasted image 20250214154748.png]]
Это самая надежная топология, т.к. если один из n сегмент упал, то его заменит любой из n-1. Минусы:
1. такая топология очень дорогая, поскольку сколько соединение (ребер), столько и сетевых карточек, а также и кабелей. 
2. Не масштабируема (при добавлении одного компьютера, надо добавить сетевую карту и провести провода)
3. Головная боль для настройки топологии -- настабильность таблиц. Широковещательный шторм, множественные копии кадров (т.к. со всех сторон приходит одна и та же информация), а также передача к одному и тому же человеку проходит по разным каналам в зависимости от нагруженности.
Обычно сильное оборудование является узлом сети.
- Частично-связная. Пусть есть узел, к которому необходимо иметь доступ. К нему проводим все связи (или как можно больше) от всех компьютеров, а к остальным в общем случае не все. Необходимо когда есть головной офис, в котором есть N филиалов. Связь должна быть постоянной и неломающейся, главный узел -- точка выхода в интернет (или несколько от разных провайдеров)

# Дисциплины передачи информации
1. Иерархическая. Существуют первичный узел и вторичный (подчиняется первичному). В такой иерархии существуют три сценария передачи:
		1) Первичный хочет передать вторичному. Последовательность: первичный сообщает вторичному о выборе его для передачи, вторичный посылает фидбек что готов, первичный передает
		2) Вторичный хочет передать первичному. Первичный периодически спрашивает есть ли что-то для передачи, второй отвечает есть, первый говорит, что готов, вторичный передает
		3) Вторичный хочет передать другому вторичному, для этого сначала информация должна пройти через первичный, то есть все идет через один узел. Пример: TeamViewer
2. Одноранговая дисциплина. Все узлы равны между собой. Поэтому все узлы имеют право вещать когда им захочется, а значит происходит коллизия -- наложение двух и более сигналов друг на друга. Поэтому получать ничего не поймет. Способы борьбы:
		а) Множественный доступ с контролем несущей и обнаружением коллизий (CSMA/CD - **Carrier Sense Multiple Access with Collision Detection**). Это технология, не протокол, работает на топологии типа "Шина".
			Пример:
			|---PC---PC---PC---PC---|
			Если вещают два и более происходят коллизии. 
			Контроль несущей: каждое устройство, которое планирует передачу данных (данные передающиеся по сети называются несущими) проверяет, что никто ничего не передает.
			Способ физической передачи сигнала: в среду передачи данных ставят генератор высокой частоты с тремя ПОСТОЯННЫМИ параметрами (частота, фаза, амплитуда). Изменяем сгенерированный по законам того как надо изменять низкую частоту.![[Pasted image 20250214161551.png]]
			Каждое устройство слушает передает ли кто то еще, если да, то мы не передаем. Включаются таймеры, чем больше точек, тем больше таймеров. Чтобы понять что пришла коллизия сравниваем со стандартами.
			Таким образом, мы CS -- контроль несущей -- проверка что никакая информация сейчас не передается, CD -- проверка, что не пришла "билиберда".
		б) Детерминированный метод. Каждому узлу выдается квант времени, в течение которого ему разрешено передавать данные. Работает на топологии типа "Кольцо".
			По кольцу бегает специальный блок, который постоянно циркулирует по кольцу. Только захватив этот блок, загрузив в него данные, вы получите способ передать данные. 

# OSI/ISO
Примерно в 1984г. появилась модель OSI/ISO (Эталонная модель взаимодействия открытых систем). То есть были убраны не open-source системы, а также установлен стандарт для принятия и отдачи сигнала. Модели взаимодействия состоят из 7 уровней:
- 7. Приложений.
- 6. Представлений
- 5. Сеансовый
- 4. Транспортный
- 3. Сетевой
- 2. Канальный
- 1. Физический.
## Физический уровень
Отвечает за электрические, механические, процедурные и функциональные характеристики физического соединения между устройствами. Т.е. отвечает за уровень напряжения, сопротивления, скорость/методы передачи данных. 
Устройства: на этом уровне работают средства передачи данных (кабели), усилители сигналов, концентратор, сетевой адаптер, медиа конвертор (преобразование электричества в свет).
На этом уровне железки передают сигналы без понятия что и куда они передают, просто двигают электричество.
## Канальный уровень
Первый уровень, который отвечает за формат данных для передачи. То есть это первый уровень (уже интеллектуальный), который понимает куда он что-то передает, т.е. видит источник и получателя. CSMA/CD и Детерминированный метод это задачи канального уровня, то есть он отвечает за методы контроля доступа к физической среде. Также на этом уровне есть такая вещь, как контрольная сумма, поэтому этот уровень отвечает за надежность передачи в содержимом (фиксирует только факт ошибки, не фиксирует место ошибки). 
Устройства: мосты и коммутаторы.
Мост -- "железка из прошлого", функционал которой совпадает с функционалом коммутатора. Разница лишь в том, что мосты работают на программном уровне, а коммутаторы на аппаратном.
Коммутатор -- устройства с большим количеством интерфейсов, соединяет конечное оборудование. Через коммутатор проходит ВЕСЬ трафик, поэтому его достоинство в скорости очень важно.
## Сетевой уровень
Отвечает за поиск и выбор оптимального маршрута между сетями географически удаленными друг от друга.  То есть поиск между компьютерами разных сетей. Если сеть одна -- отвечает канальный уровень.
Пример: компьютер в Москве, другой в Аризоне, задача найти такой маршрут, чтоб данные не поменялись.
Устройства: маршрутизатор (роутер), коммутаторы L3 (level 3, т.к. сетевой). Это последний уровень, который предназначен для того чтобы данные донести до железки. Следующие уровни -- уровни обработки данных. Параллель с жизнью: пусть есть метрополитен, нужно найти маршрут с пересадками. На сетевом уровне мы помним и начало и финал маршрута. Чтобы сориентироваться этого хватает (сетевой уровень). Канальный уровень: вы помните станцию на которую сели и до пересадки. То есть канальный уровень помнит от пересадки до пересадки.
Станции пересадки -- маршрутизаторы, их задача определить на какую сеть (линию) отправить, чтобы выйти на улицу.

## Транспортный уровень
а) Отвечает за сегментацию данных на источнике и реорганизацию в поток на приемнике.
Тяжелый файл бьет на сегменты, отправляет эти кусочки в сеть, а на приемнике это все склеивается. 
Коммутация каналов -- от источника до получателя всегда один маршрут и этот канал нельзя дать другому, пока ты подключен. 
Коммутация пакетов (по ней работают сети) -- пакеты могут отправляться по разным маршрутам (можно балансировать, по разным оборудованиям, все разное). В жизни они приходят вразнобой.
б) Создание, поддержание и корректное завершение соединения.
На транспортном уровне работает протокол с установлением соединения -- TCP (Transmission Control Protocol).
## Сеансовый уровень
Отвечает за аутентификацию. Когда вы вводите логин и пароль вы попадаете именно на свою страницу, за это отвечает данный урвоень.
## Уровень представлений
Отвечает за то, чтобы данные корректно отобразились на получателе (одна и та же кодировка)
## Уровень приложений
Связывает всю модель с пользовательскими приложениями. Предоставляет услуги именно приложениям.


# Protocol Data Unit (PDU)

На каждом уровне формируются Protocol Data Unit (PDU), его структура:
\[Заголовок]\[Data]\[Хвостовик]

Заголовок и хвостовик проверяют на ошибки, выполняют разные функции.
Data -- данные, которые хотим передать.

Допустим есть два разных компьютера, необходимо чтобы каждый уровень каждого из них общался со своим аналогичным.
[7] --[H7]-[D]-[F7]----[7]
[6]    [H6]-[D]-[F6]     [6]
[5]    [H5]-[D]-[F5]     [5]
[4]    [H4]-[D]-[F4]     [4] -- Данные на каждом уровне это полезные данные.
[3]    [H3]-[D]-[F3]     [3] -- Заголовки и хвостовики это Header и Footer уровней выше.
[2]    [H2]-[D]-[F2]     [2] -- Получается что-то вроде "Матрёшки", инкапсуляция
[1]                              [1]
- ---------------- -
Компы соединены патч-кортом, нужно передать какие-то данные. На каждом уровне формируются PDU.
На канальный уровень приходит PDU, благодаря инкапсуляции канальный уровень видим [H2]-[D]-[F2]. Далее он уничтожает Header и Footer, передает данные вверх, на третий уровень. Если все хорошо, третий делает то же самое.
Процесс, который поднимает PDU вверх и откидывает заголовки и хвостовики, называется ***"декапсуляция"***
Аналогия с метро: канальный уровень -- станция пересадки, сетевой уровень -- где спустились и где надо выйти на поверхность. Если не указать на канальном уровне промежуточное устройство, мы не поймем куда надо выйти в финале. Т.е. канальный уровень -- поезда по веткам, сетевой уровень -- откуда и куда.
На каждом уровне у PDU есть своё имя.
 - На канальном уровне -- кадр (frame).
 - На сетевом уровне -- пакет (packet).
 - На транспортном уровне -- сегмент (segment)
 На уровнях выше нет как PDU, так и протоколов. Дело в том, что интернет по OSI\ISO не работает. Весь интернет работает по разработке американского минобороны (DoD, Department of Defence). 
 Структура DoD
[5-7: прикладной]
[4: транспортный]
[3: сетевой]
[1-2: канальный]
Название PDU у прикладного уровня называется "сообщение" (message).
Есть такое понятие как стек TCP-IP, в некоторых источниках им называет DoD, но это неверно. DoD -- модель, т.е. описание уровней и их функционалов. Стек -- протоколы, обеспечивающие функционал уровней. На разном уровне разное количество протоколов, каждый протокол обеспечивает свой функционал, у каждого уровня есть свои требования к протоколу.
Модель -- описание, что оно должно делать, стек -- то что реально делает в определенной ситуации. Аналогия от Артема: модель -- абстрактный класс, стек -- конкретная реализация.
# Трехуровневая иерархическая система
![[Pasted image 20250221165733.png]]
Три уровня: доступ, распределение, ядро. В зависимости от того, что мы хотим получить от системы, связи разные. Слева сверху "документик" -- сервер, листовые вершины -- конечные устройства, а прямоугольники -- коммутаторы.
- Уровень доступа -- подключение конечных пользователей, разграничение доменных коллизий, коммутаторы второго уровня могут справиться с такими задачами.
- Уровень распределения -- маршрутизация, качество обслуживания, т.е. чей траффик быстрее передавать, безопасность (кому куда нельзя) и переход от одной технологии к другой (например, переход с меди на оптику это уровень распределения), здесь работают L2, L3 (В зависимости от того, какой функционал нам нужен). Часто этот уровень исчезает, например, если предприятие слишком маленькое.
- Уровень ядра обеспечивает передачу трафика всей системы, должен быть самым отказоустойчивым и наиболее обеспечивающим быстродействие. Когда провайдер обещает огромную скорость, он обещает каждому из конечных пользователей огромную скорость (листовые вершины), однако на уровне выше тогда будет требоваться НАМНОГО больше проходимости траффика, т.к. через этот уровень будет проходить весь трафик конечным пользователям. А ядро -- самый высокий уровень. Здесь работает только L3. "Кружочки" -- агрегация (agring channel), это когда несколько проводков объединяются в один логический канал, т.е. вместо одного физического проворачивают 4, 8 или больше проводов. Чем выше мы поднимаемся по иерархии, тем больше нам необходимо агрегации.

#Лекция 17:47
VLan TelNet -- Сети для маленьких (глава 2 или 3)
# IP
Локальные сети, зачем?:
1. Совместное использование данных
2. Совместное использование ресурсов
3. Доступ в другие сети
Группы компонентов:
1.  Конечные устройства (компьютеры, камеры, принтеры)
2.  Сетевое оборудование (коммутаторы, маршрутизаторы)
3.  Соединительные устройства
4.  Протоколы
Существуют несколько вариантов средств передачи данных:
1. коаксиальный кабель (минус: ограничение по кол-ву устройств, потому что обрабатывается CSMA CD, если рвется одно, рвется всё, ограничение по сегментам порядка 25метров)
2. Витая пара (максимальная длина сегмента -- 90 метров) 
3. Оптика (длина сегмента -- километры). Варианты оптики:
а) Одномодовая (Лазер пускает точно в сердечник, по центру). Дает большую длину сегмента, поскольку нет отражения от стенок.
б) Многомодовая. Может быть реализована и с помощью диода (не только лазер). Будет шире, чем одномодовая. Каждый луч, который мы передаем -- мода. Тут лучи отражаются от стенок и в результате могут появиться ошибки. Поэтому расстояние передачи меньше.
   4. Эфир. пример -- Wi-Fi
На данный момент самый распространенный вариант -- витая пара. Для того, чтобы избавиться от недостатка максимальной длины, используются хабы. Хабы усиливают сигналы, однако данные в каждый хаб все равно приходят с шумом. Между двумя конечными устройствами не может быть больше, чем 4 хаба (чтобы не было слишком сильного зашумления данных). Поэтому максимальная длина между двумя устройствами -- 450 метров. К хабам могут добавляться компьютеры, тогда такая топология физически -- звезда, логически -- шина. 
# Switch (коммутатор)
Домен коллизий -- совокупность устройств, которые борются за одну линию передачи.
Аналог хабов -- switch (коммутатор). Он разбивает домен коллизий. У свитча есть микро-сегментация (насколько я понял из лекций мфти, это когда в домене коллизий одно конечное устройство).
Свитч имеет несколько разъемов для патч-кортов, это интерфейсы (Ethernet (10 MiB/s), Fast-Ethernet (100 MiB/s), GigaBit (1000 MiB/s)). На нем есть цифры, сверху нечетные, снизу четные. У каждого интерфейса есть лампочка (рисуются либо сверху, либо слева от слотов).
Благодаря номерам интерфейсов свитч знает на каком интерфейсе "сидит" конкретная железка. Микросегментация проявляется в случае, если, например А хочет пообщаться с В, а В с С.
С помощью микро-сегментации свитч делает коммутационную матрицы и соединяет железки. У каждой железки есть два буфера: входящий и выходящий. Очередь освобождается по принципу FIFO (если не было изменений этой конфигурации).
Буфер -- память, в которую на время помещаются данные.
# mac-адрес
Как свитч узнает где какая железяка? У свитча есть таблица коммутаций -- сопоставление номера интерфейса и его mac-адреса.
mac-адрес -- физический адрес, который назначается производителем на устройство. Любое устройство, которое выходит в интернет обладает *уникальным* адресом. mac-адрес занимает 48 бит (6 байт) и состоит из двух частей:
1) ID организации. ID организации, которая производит устройство. Иногда одна организация неправильно может сделать одинаковые ID устройства. В таких ситуациях можно перепрошить mac-адрес, выставляя "галочку, битик", который будет говорить о собственноручном изменении mac-адреса. Есть база данных таких айди
2) ID устройства. Таких баз данных нет.
![[Pasted image 20250228182433.png]]
В любой таблице существуют два типа записи: статическая и динамическая. 
1) Статическая -- ручная запись, она не стареет, всегда актуальна. Ее минус -- в realtime невозможно перестроить (например, если взять два патч-корта и переставить местами, таблица не обнаружит изменения устройства). Здесь необходимо следить за правильному написанию mac-адреса.
2) Динамическая создается автоматически, поскольку слушает трафик, который проходит. Как он создает? Есть Ethernet-протокол, PDU которого выглядит следующим образом:
[DA]-[SA]-[TYPE]-[DATA]-[FCS]
[6]-[6]-[2]-[46-1500]-[4] -- количество байт, которые занимают ячейки.
DA -- Destination Address -- заголовок, адрес доставки
SA - Source Address -- адрес отправителя
Type -- тип протокола
Data -- информация
FCS -- Frame Control Sequence -- хвостовик, контрольная сумма
Вопрос на экзамене: что было в помещении Технопарка (еще до МИПКа)?
Разновидность по объему памяти в таблице коммутации:
1) SOHO (Small Office Home Office) -- объем таблиц порядка тысячи записей.
2) SMB (Small Medium Buisness) -- порядок записей примерно до 48 тысяч.
3) ISP (Internet Server Prodiver) -- то, что ставится на магистралях, порядка 128 тысяч записей
Может быть столько мак-адресов на интерфейсе, сколько хватает памяти.

Три варианта коммутаций:
1) Буферизация. В буфер попадает весь кадр, анализируется на наличие коллизий и ошибок. Если таковых не выявлено, то кадр отправляется в место назначения. Самый НАДЕЖНЫЙ вариант (поиск и коллизий и ошибок). Самый МЕДЛЕННЫЙ вариант (по той же причине)
2) Без буферизации. В буфер попадает только первые 6 байт, определяется куда отправить и отправляется. самый БЫСТРЫЙ и самый НЕНАДЕЖНЫЙ вариант (поскольку нет проверки). Написать кадр по памяти -- легко, поскольку на канальном уровне будет первым полем DA именно для этого. На остальных уровнях (кроме канального) будет SA, потом DA. Это сделано для оптимизации канального уровня, необходимо, поскольку весь трафик проходит через канальный уровень.
3) Без фрагментная буферизация. В буфер попадают первые 64 байта, анализируются на наличие коллизий, на ошибки не анализируется, если коллизий не нашлось, отправляются далее. Почему 64? При наших скоростях на данный момент если за время которое вам требуется чтоб передать 64 байта первых не произошло коллизий, то её и в целом не произойдет.
Варианты коммутаций не настраиваются, а выбираются производителем. 

Свитч обладает определенными функциями:
1) Пересылка. Свитч в таблице коммутации может найти получателя и отправляет на конкретный интерфейс (отправление только получателю и никому более)
2) Лавинная рассылка (Flooding). Если свитч не знает, на каком интерфейсе находится получатель, он кидает на все интерфейсы, кроме того, на который получил. 
3) Фильтрация. Свитч уничтожит кадр, если кадр предназначается тому же сегменту, с которого пришел.
Как это работает (иллюстрация на доске)?
Допустим есть три компа, соединенных через свитч (пусть A,B,C -- мак-адреса, 01 02 03 -- интерфейсы). Пусть общение происходит от В к А. Что делает свитч (С БУФЕРИЗАЦИЕЙ)?
1) Смотрит кто отправил
2) Создает новую запись в таблице: 0/1 А -- на 0/1 интерфейсе мак-адрес А (тут же происходит запуск таймера, т.к. динамическая запись)
3) Так как не знает где В, кидает всем.
4) Доставил данные В.
Из В в А
1) Отправили данные из В в свитч
2) Свитч нашел 0/1 А в свитче
3) Отправил в А
Из А в С
1) Отправил данные из С в свитч
![[Pasted image 20250228185731.png]]

Пусть есть 4 компа, 2 свитча. Вверх по иерархии сети уходит либо 1й либо последний интерфейс (24, 48), чтобы проще было ориентироваться в многообразии проводов.
![[Pasted image 20250228190022.png]]Пусть [C]-[B]
Ловушка в том что была попытка перезаписать 0/1 (но не надо было удалять 0/1 А)
![[Pasted image 20250228190744.png]]
Пример фильтрации: Из А в В, но не будет записи В в первом свитче.
Канальный уровень -- все. Потом к нему вернемся.
Здесь мак-адрес не давал понимания где железка, но давал понимание кто изготовил.
# Сетевой уровень
Здесь используются IP-адреса, который логически назначаются человеком и подсказывают где находится устройства. Содержат 32 бита, записываются в 10чной системе счисления.
пример: 192.168.1.1 (октет, 8 битов)
есть два типа адресации:
1) Классовая. IP-адрес глобально делится на две части: адрес сети и адрес хоста. Пример в жизни: пусть есть улицы, на них частные дома. Адрес сети -- название улицы, адрес хоста -- номер дома на улице (конечное устройства). В классовой адресации есть пять классов: A, B, C, D, E. В зависимости от класса где находится сетевая часть. На А больше всего места для хостов. У D и Е нет таких понятий. Класс D предназначен для групповой рассылки. Класс E просто прозапас, на будущее разработки, но он не получил развития. Из него используется только один адрес. Тип класса определяется по первому октету, если старший бит нолик -- это А, 10 -- В, 110 -- С. В приведенном примере 192 = 110...00, это тип С.![[Pasted image 20250228194137.png]]
2) бесклассовая
Не бывает IP без маски. Маска тоже показывает границу сеть-хост. При изготовлении плат накладывают маску на плату. Маска тоже занимает столько же бит и в той же системе счисления, тоже записывается четырьмя октетами. Там где 1 там сеть, там где 0 там хост. Сначала идет куча единиц, потом куча нулей. Многие источники говорят сделать с маской логическое или. Метод Тихомировой на примере 192.168.1.1:
192 = 110000000
168 = 10101000
1 = 00000001
1 = 00000001

110000000.10101000.00000001.00000001

Это класс С. В классе С три октета -- сеть. Поэтому:
11111111.11111111.11111111.00000000
значит:
255.255.255.0
ИЛИ
192.168.1.1/24, где 24 -- количество единиц в маске в двоичной системе счисления.
Зависит от операционной системы.


# Лекция 21.03
#лекция21/03

Зарезервированные адресы:
1. Адрес сети 192.168.1.0 -- хвостовые биты забиты единицами. Не может использовать в качестве источника/получателя, но используется маршрутизаторами, чтобы помнить где что находится.
2. Локальный широковещательный адрес 255.255.255.255 -- все биты единицы, является только НАЗНАЧЕНИЕМ, тот пакет в качестве которого он назначение принадлежит всем устройствам сети. Используется только 4 раза, когда устройство только появляется в сети и еще не знает, в какой оно сети появилось.
3. Направленный широковещательный адрес 192.168.1.255 -- все хвостовые биты единицы, выступает только в качестве получателя, используется всеми устройствами данной сети. Используется когда устройство знает в какой оно сети и отправляет запрос всем устройствам сети.
4. Неопределенный 0.0.0.0 -- когда устройство только включилось оно имеет такой адрес. Дальше этот адрес превращается в другой айпишник, если он выбирается автоматически и не находится выбирается пятый вариант
5. Автоконфигурации 169.254.0.0 -- выступает в роли "маяка", первым делом при багах проверяем айпишник устройства, если видим его, значит что проблемы с доступом сервера. Проверяем все снизу вверх по OSI\ISO, физику, сервер и т.д.
6. Localhost 127.0.0.0 -- любой адрес из этой сети. Если пинг по этому адресу не работает, значит не работает TCP/IP-стек, т.е. сломана сетевая карта. 

Серым айтишником (частным) можно пользоваться только в локальных сетях. Публичные -- те, за которые придется платить провайдеру деньги.
Интернет -- совокупность локальных сетей. В точке соединения идет подмена: "NAT" -- Network Address Translation -- технология, задача которой взять пакет при выходе из точки соединения, вытащить серый пакет, поместить туда оплаченный белый и отправить в сеть. На возврате NAT вернет обратно в адрес назначения серый айпишник.
![[Pasted image 20250321200205.png]]
Существуют три варианта NAT:
1) Статический. Забить руками пары серый:белый, то есть сами разрешаем с каким серым айпишником можно выходить в интренет. Существуют до ручного удаления. В интернет может выйти столько устройств, сколько белых айпишников. Используются для "проброса", когда он прячет локальную сеть от внешней сети. Он соединяет белый статический айпишник с внутренним частным айпишником. Например, в локальной сети есть сервер и хотим из вне туда лазить. NAT будет пропускать в локальную сеть.
2) Динамический. В этой ситуации создается пулл белых айпи адресов, которые будем раздавать серым айпишникам. С помощью специальной политики безопасности разрешаем кому именно можно выходить в интернет. Тут пары создаются оборудованием. В единицу времени в интернет выходит максимум устройств, сколько белых айпишников. В динамике можно сначала выйти с одним айпишником в сеть, а потом уже с другом, т.е. айпишники присваиваются динамично.
3) PAT -- Port Address Translation (Перегруженный NAT). Все устройства из частной сети в интернет прячутся ровно за одним айпишником (обычно это белый айпишник). То есть все серые относятся к одному белому. В этой ситуации порядка 64000 устройств могут одновременно выйти в глобальную сеть. Как точка соединения определяет как именно надо вернуть? Пусть есть серый айпишник у него есть порт 192.168.1.2:51537 -- socket = ip + port, номер порта идентифицирует процесс в ОС. Такому сокету дают белый айпишник и запоминают какому номеру порта это соответствуте, например, 1.1.1.1:51537.
Пусть теперь есть следующий серый айпишник 192.168.1.3:49943->1.1.1.1:49943, на основе номеров портов возвращается нужный серый айпишник. Несколько операционок в целом могут попасть в один и тот же номер порта, в этой ситуации на выходе роутер возьмет свободный порт, а на возврате возьмет родной.
#### Классовая адрессация
А: 10.0.0.0
В: 172.16.0.0 -- 172.32.0.0
С: 192.168.0.0 -- 192.168.255.0
#### Бесклассовая адрессация
2 разновидности адрессации (просто алгоритмы):
VLSM (Variable length subnet mask):
1) айпишники делятся на: сеть, подсеть, хост. Маска показывает место, где начинается хост. Границу между сетью и подсетью показывает класс.
2) Пример: ![[Pasted image 20250321202253.png]]
Пусть надо настроить топологию, используя одну сеть 192.168.1.0/24. Сеть одна, надо три. Все что скрыто под маской (192.168.1) трогать нельзя. Последний октет не покрывается маской.
![[Pasted image 20250321203255.png]]

192.168.1.0/24
разбить на 7 подсетей
написать адрес 39го хоста в 4 подсети

![[Pasted image 20250321203920.png]]
Но неправильно, потому что на самом деле максимальное число справа 31.
#Лекция28_03
Еще задача:
CIDR (Classless InterDomain Routing, бесклассовая адрессация):
У сидра нет ограничения, маска может двигаться как вправо так и влево.
Раскладываем первую подсеть, получается десятка в двоичной систем
10|0.0.0/5
00001:01000
8.0.0.0/5

Железо ориентируется только на маску, VLSM и CIDR для удобства человеку.

# Как выглядит заголовок пакета IPv4?

![[Pasted image 20250328180733.png]]
Цифры сверху -- количество бит, которое занимает поле. Это только заголовок, данные идут после него.
1. Первое поле -- так как протокол 4 версии, там записаны цифры 4
2. Второе поле измеряет то, что написано по одной причине: поле переменной длины, может присутствовать, может не присутствовать. Измерение идет в СЛОВАХ, одно слово -- 4 байта. Допустим, у нас нет поля переменной длины, остальные фиксированные и есть. Какое значение записано во втором поле заголовка, при условии отсутствия этого поля? Одна строка таблицы -- одно слово, таким образом, будет 5 слов. То есть если нет поля "опции", то его длина 0, а значит
3. Тип сервиса выглядит следующим образом.![[Pasted image 20250328182616.png]]
4. Бит задержки. Следующие три бита используются только в том случае когда до сети назначения есть два и более равнозначных маршрутах. Если есть только один маршрут и не из чего выбирать, то на биты не смотрят. Если выставлен, то выбирается канал с минимальной задержкой. Следующий бит -- пропускная способность (throughput). Bandwith -- заявленная пропускная способность, throughput -- реальная пропускная способность, которая стремится к заявленной, но в большинстве случаев не достигает её. Чем выше нагрузка (чем больше трафика), тем меньше пропускная способность. Логичнее брать ту пропускную способность, которая в real-time показывает то, что происходит в сети. Если бит выставлен выбирается маршрут с максимальной РЕАЛЬНОЙ пропускной способностью. Чем меньше задержка, тем больше пропускная способность. Третий бит -- надежность (reliablity). Если выставлен данный бит, выбирается маршрут с максимальной надежность, т.е. минимальным процентом потери пакетов. Если на маршрутизаторе написать show interface fa0/0, то увидим показания этих критериев. И в зависимости от времени в real-time эти показания будут меняться, если каждый раз вбивать show interface fa0/0.
5. Два бита занимаются ECN (explicit congestion notification) -- явное сообщение о перегруженности (задержки). Когда буфер переполняется, трафик отбрасывается, на основе битиков транспортного уровня источник понимает что трафик не дошел и будет пытаться повторить, тем самым дополнительно нагружая сеть. Сеть и так была перегружена, а перегруза будет еще больше. Промежуточное устройство, когда понимает, что память на пределе, оно отправляет сообщение с помощью этих битиков источнику траффик с фразами "стоп". Источник останавливает передачу и ждет, когда придет сообщение "продолжай". Для источника равносильно тому, что трафик уничтожается (в обоих случаях, в первом они уничтожатся, во втором не отправятся). Но для сети это проще, поскольку сеть освободится.
6. Длина пакета -- просто измерение длины пакета в байтах. Если длина слишком большая, пакет разбивается на фрагменты. Поэтому каждый фрагмент нужно идентифицировать с тем, какому пакету надо его отнести. Первое поле будет айдишником пакета (у студентов это номер учебной группы, т.к. они её фрагмент). Далее необходимо понять разрешена ли фрагментация или нет.
	1. Флаги -- 3 бита. Обычно всегда обозначается нулем, а в документации крест. Крест поскольку все равно что 0 что 1. Следующий бит говорит разрешена ли в целом фрагментация. Последний бит говорит о том, последний ли фрагмент последовательности.
7. Указатель фрагмента. Пусть есть пакет который разбит на три фрагмента, указатель покажет положительное смещение относительно начала пакета, то есть куда именно пристыковать фрагмент (не номер фрагмента, а положительное смещение в байтах).
8. Время жизни (Time To Live) -- сколько реально осталось жить пакету. Раньше измерялось во временных единицах, однако это убрали, поскольку невозможно спрогнозировать сколько пакет будет идти, если не знаем дистанцию передачи. Сейчас TTL это число, которое декрементируется на каждом маршрутизаторе. Как только TTL достигает нуля, пакет уничтожается. Нужно чтобы пакет не зацикливался в сети, чтобы не бегал бесконечно. Максимальное значение 255, т.к. 8 бит. 
9. Протокол -- код протокола, которому необходимо передать содержимое поле данных. Такое поле было и в ethernet, называлось тип. То есть кому выше надо передать то, что сидит в данных.
10. Контрольная сумма -- поиск ошибок (контроль четности). Пусть надо передать пять битов. Контроль четности применяет XoR (просто четность), в итоге должна получиться единица. В результате должна получиться такая же
11. Адреса уже знаем.
12. Опции могут быть могут не быть. Делятся на классы: первый и третий зарезервированы, нулевой -- отладка, второй -- дейтаграммы пользователя. Отладка просто помогает где был пакет, каждое устройство пишет "этот пакет был на мне" и это можно посмотреть. Заполнитель добавляет нулевые биты до кратности 32.
Откуда появляются айпишники:
а) задать вручную
б) через DHCP (Dynamic Host Control Protocol) -- протокол, динамически обозначающий айпи адреса. Протокол прикладного уровня, т.е. работать будет только тогда, когда запущена ОС. Работает поверх UDP, т.е. инкапсулируется в UDP (поймем только к экзамену).
Что выдает DHCP? 
а) Айпи, маску
б) default gateway
в) DNS -- сервер, функционал которого разрешать доменное имя. https инкапсулируется в сетевой уровень, а пользователь написал доменное имя (vk.com), DNS-сервер должен сказать какой айпишник у vk.com. 
Как происходит обмен между устройствами?
По алгоритму DORA
а) Когда устройство только появилось в сети, оно получает айпи 0.0.0. и кидает DHCP-discover, смысл которого "эй, отзовись". Адрес назначения -- широковещательный, т.е. 255.255.255.255. Это связано с тем, что он еще ничего не знает и посылает пакет всем, кому может. В ответ DHCP кидает DHCP-offer, адрес назначения которого также 255.255.255.255. Это связано с тем, что адрес еще не определен, а значит и направить на него ничего нельзя. В ответ, когда хост увидел приглашение от сервера, он кидает DHCP-requets. Его смысл сказать "я согласен", адрес назначения 255.255.255.255. Это связано с тем, что в сети может быть несколько DHCP-серверов, этот пакет пошлется всем из них и сообщит о том, кого выбрали. DHCP-Acknowledgment, адрес назначения 255.255.255.255. Тут он фиксирует, что выделил ресурсы. Широковещательный, потому что айпишник присвоится только после Ack.

DCHP 3 варианта:
1) ручное назначение статических адресов. Это означает, что mac-IP пары создаются руками и остаются вплоть до удаления. Полезно для периферии, чтобы не настраивать принтер каждый день заново. 
2) динамическое назначение статических адресов. Задается пул айпишник. Когда устройство начинает стучаться, выдается айпишник mac-IP и сохраняет их. Этот вариант для тех, кто либо боится опечататься в mac, либо для ленивых. В этой ситуации есть один нюанс -- пока не раздали весь пул адресов, нужно следить, чтобы никто чужой не пробрался в сеть, поскольку одно из ваших устройств не получит выделенный айпишник.
3) автоматическое назначение динамических адресов. в этой ситуации задается пул адресов(либо начало-конец, либо количество), задается время аренды (т.е. время в течение которого устройство имеет право пользоваться айпишником). По истечении времени айпи возвращается на базу, если устройство еще работает, айпишник выдается еще раз обычно. Так как пара mac-IP существует только в момент использования, то когда выдается второй раз айпишник меняется.
Протокол сетевого уровня ICMP ( **Internet** **Control** **Message** **Protocol**). Основные назначения:
а) отладка
б) сообщение об ошибках
Во многих источниках рисуют между транспортным и сетевым уровнем. Транспортный неверно, поскольку там используются в качестве адресации номера портов, а в ICMP портов нет. Относится к междууровневому, поскольку ICMP инкапсулируется в IP, т.е. сетевой инкапсулируется в сетевой, поэтому происходят непонятки.
Как выглядит ICMP?
![[Pasted image 20250328194458.png]]
Тип определяет о чем сообщает пакет, а код конкретизирует. Например, в типе написано адресат не достижим, а в коде -- сеть неизвестна/недоступна, адресат недоступен в сети, т.е. причина почему адресат не достижим. 
Исключения на что ICMP не отправится:
а) ICMP не отправится на потерю ICMP. Допустим есть несколько маршрутизаторов и бежит пакет с данными. Например, контрольная сумма не совпала и маршрутизаторов, заметив это, уничтожает пакет и отправляет пакет обратно. Запускается ошибка на первом маршрутизаторе, но первый уже не вернет обратно, поскольку это был бы замкнутый круг. Вот этот момент и есть исключение.
б) на потерю широковещательного трафика. Пусть мы отправили запрос широковещательно и все устройства уничтожили ICMP кроме одного которому надо ответить. Они не сообщают об удалении.
в) ICMP не отправляется на потерю не первого фрагмента фрагментированного пакета. Если потеряли уже не первый фрагмент, то есть уже второй фрагмент удалился, то мы об этом не сообщаем. Так как если потерян один пакет, то все остальные пакеты будут повторены, а значит нет смысла сообщать об остальных. 
Примеры: пинг
C:\\> ping 192.168.1.2
Трассировка маршрута (tracert) -- простукивание всех промежуточных устройств, которые понимают сетевой уровень. Там где не ответили -- там проблема. Как он это делает? Отправляет с разными TTL, если уничтожается на роутере, роутер сообщает это и говорит причину уничтожения. Если доходит, то конечное устройство возвращает успех.

ARP (Address Resolution Protocol) -- протокол сетевого уровня, предназначен для разрешения айпи адреса в мак адрес, т.е. по известному айпишнику ищем неизвестный мак. Есть статическая и динамическая запись. Динамическая запись появляется благодаря рассылке пакетиков. У них есть время жизни, но за этим следят машины. Все это хранится в таблице. По таблице свичи могут делиться на разновидности.

![[Pasted image 20250328200817.png]]
Hardware Length -- сколько содержит байт мак адрес, то есть 6 байт
Protocol Length также содержит об айпи адресе, 4 байта.
Operation -- задает функционал в пакетах.
![[Pasted image 20250328202204.png]]
Target Hardware Address -- то что ищем, на запросе поле будет забито нулями, а на ответе будет значение.
Target Protocol Address -- айпишник, по которому мы ищем.
Если мы не найдем мак, пдюшка сдохнет на источнике.

RARP -- Reverse ARP. Протокол по известному мак адресу ищет неизвестный айпи. Когда это нужно? DHCP прикладного уровня, заработает тогда, когда запустится ОС, но есть такое понятие, как бездисковая станция, то есть станции без ОС (ОС загружаются с серваков). То есть для запуска ОС им нужен айпи, а айпи только после запуска ОС. Поэтому есть протоколы (например, BOOTP). Например RARP отправляет запрос "у меня такой мак адрес, какой айпи?" Получает айпи и посылает запрос с ОС.


#Лекция040425
# Задачи с экзамена

## Отправка пинга (ICMP-пакет) -- Два компа

До этого мы не настраивали мак-адреса. Теперь будем настраивать сами.

A:\> ping 192.168.1.2

В результате сформировался icmp-запрос, который инкапсулируется в IP.

[...]-[1.1]-[1.2]-[...]-[]

Только на канальном уровне первым идет Destination

Далее это инкапсулируется в Ethernet

[?]-[A]-[IPv4]-[]-[FCS]

ARP-запрос инкапсулируется в Ethernet:

[12*F]-[A]-[ARP]-[]-[FCS]

Дальше это доходит до B, он деинкапсулирует, заглядывает внутрь и формирует ARP-ответ:

[A]-[B]-[ARP]-[]-[FCS]

Потом компьютер узнает мак-адрес В и посылает Ethern.

Когда ICMP-запрос доходит до B, B его инкапсулирует и формирует ответ.

ICMP-ответ

[]-[1.2]-[1.1]-[...]-[]

Формируется в IP:

[A]-[B]-[IPv4]-[]-[FCS]

  

##  Три компа со свичом

192.168.1.2/24 (A) -- fa0/1 -- Switch

192.168.1.3/24 (B) -- fa0/2 -- Switch

192.168.1.4/24 (C) -- fa0/3 -- Switch

  

A:\\> ping 192.168.1.4

1) ICMP-запрос:

2) IP-Запрос

[...]-[1.2]-[1.4]-[...]-[]

3) Ethernet

[?]-[A]-[IPv4]-[]-[FCS]

  

Формируется ARP-запрос:

а) [12*F]-[A]-[ARP]-[]-[FCS]

  

Доходит до свича, он посмотрел mac-адреса и посмотрел в таблицу. Записал туда mac-address-source:

б) 0/1|A + TImer

  

ARP-ответ:

в) [A]-[С]-[ARP]-[]-[FCS]

  

Ответ доходит до свича, тот записывает С в mac-table и отправляет сразу на А.

  

г) А формирует ICMP запрос:

[C]-[A]-[IPv4]-[]-[FCS]

  

д) ICMP-ответ от B к A:

[C]-[A]-[IPv4]-[]-[FCS]

[]-[1.4]-[1.2]-[]-[FCS]

  

е) Это доходит до свича, свич обновляет таймер

ж) Доходит до компа

  

## Роутер и три компа

192.168.1.2/24 (А) -- (default gateway 1.1) -- fa0/0 -- Router (AA)

192.168.2.2/24 (В) -- (default gateway 2.1) -- fa0/1 -- Router (BB)

192.168.3.2/24 (С) -- (default gateway 3.1) -- fa0/2 -- Router (CC)

  

A:\\> ping 192.168.3.2

  

1) ICMP-запрос от А к С

2) IP-запрос: [...]-[1.2]-[3.2]-[...]-[]

3) Ethernet:[?]-[A]-[IPv4]-[]-[FCS]

4) ARP-запрос: [12*F]-[A]-[ARP]-[data]-[FCS]

Здесь надо смотреть какая сеть, поэтому в ARP-запросе будет dg (default gateway)

5) Запрос доходит до роутера, роутер говорит свой мак обратно ARP-ответом:

[A]-[AA]-[ARP]-[]-[FCS]

6) Комп залезает внутрь, видит что это ответ на его запрос, отправляет ICMP, где destiation = AA: [AA]-[A]-[IPv4]-[FCS]

7) После того как это дойдет до роутера он маршрутизирует на нужную сеть. После подключения интерфейса роутер уже знает, где какая сеть, поэтому ему не нужно это узнавать. Он определяет на каком интерфейсе находится нужная (третья) сеть и создает третий кадр: [?]-[CC]-[IPv4]-[]-[FCS]

8) Летит ARP-запрос: [12*F]-[CC]-[ARP]-[]-[FCS]

9) Долетает до компа, тот видит что широковещалка, заглядывает внутрь, видит айпишник свой и формирует ARP-ответ: [CC]-[C]-[ARP]-[]-[FCS]

10) Маршрутизатор сделал ICMP-кадр, который доходит до компа, тот инкапсулирует, видит свой айпишник и видит ICMP-ответ: [...]-[3.2]-[1.2]-[,,,]-[] -> [CC]-[C]-[IPv4]-[]-[FCS

11) Маршрутизатор получает этот пакет, формирует ICMP-ответ на компьютер A.

  

## Два компа, два свича, еще два компа, VLAN2 и роутер

  

PC1: 192.168.1.2/24 (А) -- dg: 1.1

PC2: 192.168.1.3/24 (B) -- dg: 1.1

PC3 (vlan2) : 192.168.2.2/24 (С) -- dg: 2.1

PC4: 192.168.2.3/24 (D) -- dg: 2.1

Router 0/0 (AA):

1) 0/01: 192.168.1.1/24

2) 0/02: 192.168.2.1/24

  

ICMP (A->D):

1) ICMP -> IP: []-[1.2]-[2.3]-[]-[]

2) IP -> Ethernet: [?]-[A]-[IPv4]-[]-[FCS]

3) ARP-запрос: [F*12]-[AA]-[ARP]-[]-[FCS]

4) Sw1 записал A в 0/2. Переход в Sw2

5) Sw2 записал F в 0/2

6) ARP-ответ от роутера: [A]-[AA]-[ARP]-[]-[FCS]

7) Sw2 и Sw1 записали АА в 0/1

8) ICMP запрос летит, Sw1, Sw2 обновляют таблицу

9) S2 смотрит dest, отправляет в 0/1. Роутер видит на канальном уровне -- ему, на сетевом -- нет. Формируется ICMP, а потом ARP-запрос, чтобы узнать mac-address компа D. Добавляется VLAN ID

Транк порт нужен для прослушки сети с одного компа, происходит зеркалирование трафика на комп всего что проходит через коммутатор.

10) IP-запрос: [?]-[AA]-[2]-[IPv4]-[]-FCS]

11) S2 запишет снова в мак-таблицу, пошлет в S1, тот тоже обновит и пошлет в C, а S2 пошлет в D. D ответит маршрутизатору и последний узнает мак-адрес D. Маршрутизатор посылает ICMP в D, тот отвечает, маршрутизатор посылает в A ICMP-ответ.
    <Тут должна быть фотка, но Tengen Nikita скинул лекцию в .md и она не сохранилась>

#Лекция110425
# IPv6. 
Был создан, чтобы решить проблему адресного пространства, IPv4 закончились примерно еще в 2014 году, поэтому были созданы IPv6.
1) В IPv6 128 бит, то есть первое преимущество - это расширенное адресное пространство. 
2) Отсутствие широковещательного адреса => не будет штормов. Широковещательная рассылка была заменена на групповую.
3) Также достоинством IPv6 является функция Plug and Play. Устройство само назначает себе уникальный IPv6 адрес
4) Упрощенный заголовок
## Как выглядит заголовок IPv6?
![[Pasted image 20250411174707.png]]
1) Flow Label: все что вы передаете скорее всего будет передаваться несколькими пакетиками. Все пакеты, которые переносят части одного и того же файла должны идти по одному маршруту. Берется рандомное 20битное число и записывается в поле. Первый пакетик анализируется маршрутизатором (куда отправить и надо ли вообще отправлять, приоритеты, требования по надежности) и он принимает решение выпускать или нет и если да, то с какого интерфейса. Решение записывается в кеш. Когда приходит второй пакетик, в кеше ищется такая же метка потока и такой же айпи адрес, если находится, выполняется уже заготовленное действие.
2) Payload Length: длина пакета. Так как нет полей переменной длины, то интересно сколько весит только пакет.
3) Next Header: аналог поля Protocol в IPv4, то есть куда декапсулировать.
4) Hop Limit: TTL
5) Адреса источника и назначения занимают 128 битов
![[Pasted image 20250411180624.png]]
Она считается только на канальном и транспортном уровне.

## Какие бывают айпишники?
1) Unicast -- передача от одного устройства к другому (1:1)
2) Multicast -- от одного ко многим (1:N) (вместо Broadcast)
3) Anycast -- альтернативный, от одного к ближайшему. Ближайший с точки зрения сети, а не географически.
Примеры:
   а) 0C85:2710:0000:0000:0000:0000:0000:02А0
   ИЛИ
	C85:2710::2A0
	C85:2710:0:0:0:0:0:2A0
Типы Unicasts:
	а) Глобальный unicast: префикс [2000::/3]. Это белый (публичный) айпи.
	б) Локальный площадки: префикс [FD::/8]. Бегает по локальной сети. 
	ба) Локальный канала: префикс [FE80::/10]. Если источник это, то он не выйдет за пределы маршрутизатора. Для служебной рассылки.
	в) Неопределенный адрес: :: (все нули)
	г) Localhost: всего один адрес ::1 
### Глобальный айпишник
![[Pasted image 20250411181917.png]]
### Локальный айпишник площадки
![[Pasted image 20250411181943.png]]
- Global ID: псевдослучайное число, айдишник который для всех подсетей локальной сети должен быть один и тот же.
- Префикс подсетей: номер подсети локалки.
### Локальный айпишник канала
![[Pasted image 20250411182013.png]]
Так как пакеты не выйдут за пределы маршрутизатора, то все адреса Global ID и Subnet не имеют смысла. Поэтому тут нолики.
### Откуда взять ID интерфейса?
1) Придумать самостоятельно;
2) DHCP сервер (все равно что-то придется придумывать, диапазоны устройства например);
3) EUI-64 (MAC-адрес (48) -> ID Interface (64)): берет мак-адрес, рассоединяются части (айди организации и айди железки), между ними вставляется FFFE. Это будет айди интерфейса для устройства. Как без DHCP назначить себе мак-адрес? Это Plug-and-Play
4) Plug-and-Play. Когда устройство только появляется в сети, оно (ОС) знает айпи всех маршрутизаторов. Устройство отправляет Multicast всем маршрутизаторам (по IPv6). Маршрутизатор представляется по запросу, устройство узнает первые IP маршрутизатора. Первые 64 бита крадем у полученного айпи маршрутизатора, а в остальное вставляю сгенерированный по EUI-64 айпи.
#  Введение в маршрутизацию
![[Pasted image 20250411183845.png]]
Топология "рыба". 

.1 и .2 -- значения последнего октета. Задача маршрутизации найти маршрут из точки А в точку В. Маршрутизатор должен принять решение пустить сверху или снизу пакет. Он может считать по количеству промежуточных узлов (нижний), может по пропускной способности, на надежность, на загрузку, на задержку и т.д.
В мозгу каждого маршрутизатора присутствует таблица маршрутизации. Первое что туда попадает -- собственный айпи
![[Pasted image 20250411184725.png]]
− DC (Directly Connected) – напрямую подключенный;
− 120 – административное расстояние. Адм. расстояние – степень доверия источнику
информации (0-255) – чем меньше, тем больше доверия (+ чем интеллектуальней протокол, тем меньше):
	• 0 – самому себе (DC);
	• 1 – статические записи;
− via [Next Hop] – «через адрес IP-address [Next Hop]»;
− 2 – метрика – расстояние от точки (маршрутизатора) до сети назначения (чем меньше, тем больше приоритет). Тут -- количество промежуточных узлов;
− 192.168.3.2 – IP-address Next Hop (чтобы по нему пошел ARP);
− fa0/1 – собственный интерфейс, с которого надо выйти.

Сеть -- это что-то классовое, подсеть: маска отличается от классовой.

### Параметры протоколов маршрутизации
1) Оптимальность алгоритма – характеризует способность алгоритма выбирать оптимальный маршрут, который выбирается по показателям и их весу (например, количество промежуточных устройств, пропускная способность, надежность, загрузка, задержка);
2) Низкие непроизводительные затраты – алгоритм маршрутизации должен обеспечивать свой функционал при минимальных затратах ПО. Если маршрутизаторы будут тратить много сил на расчеты маршрутов, то пострадает конечный пользователь.
3) Стабильность работы – алгоритмы маршрутизации должны четко функционировать в случае неординарных, непредвиденных обстоятельств. Характеризует способность протокола обеспечиваться работу в нестандартных ситуациях; Например, отказ оборудования, условия высокой нагрузки, некорректная настройка.
4) Быстрая сходимость алгоритма – процесс соглашения между всеми маршрутизаторами сети об оптимальных маршрутах. Все маршрутизаторы общаются между собой и рассказывают о существовании сетей. На этих знаниях выстраиваются таблицы маршрутизаций, она должна быть одна и та же для всех маршрутизаторов. Не совсем корректно, правильно надо сказать, что каждый маршрутизатор одинаково знает как дойти до каждой сети.


### Классы протоколов маршрутизаторов
![[Pasted image 20250411185941.png]]
1)
Статические протоколы -- просто набор правил, максимально простые протоколы. Не подстраиваются под real-time изменения. Должны быть настроены до запуска сети.
Динамические протоколы -- функционируют посредством обмена апдейтами. Динамика про локалку, статика про глобальную сеть, поскольку невозможно узнать все сети мира. Типа DG компьютера.

2)
Одномаршрутные подразумевают, что возможен один оптимальный маршрут, многомаршрутные, что несколько. Современные маршрутизаторы по умолчанию разрешают до 4 маршрутов. Есть протоколы, которые умеют балансировать между оптимальными маршрутами при условии неправильных, то есть считать оптимальным маршрутом не только лучший маршрут, но и наиболее близкие. Это дает балансировать трафик

3)
В одноранговых все маршрутизаторы знают про абсолютно все сети, в иерархических только про те, которые находятся в их зоне.
Area 0 соединяет остальные звоны. По сути это принцип мобильной связи, при наборе номера сигнал уходит до вышки, по ним прыгает до вышки получателя и потом на мобильник получателя. Вышки это Area 0. 
1) Служебная информация остается в пределах зоны, не захламляется сеть. 
2) Так как маршрутизаторы знают про те сети, которые находятся в своей зоне, то у них меньше таблицы маршрутизации => быстро и эффективно по памяти. 
Когда огромная сеть это используется, когда маленькая нет.

4)
Дистанционно-векторный и состояние каналов.
В первых маршрутизатор общается только со своим соседом и на регулярной основе рассылает свою таблицу маршрутизации. В состоянии канала маршрутизаторы общаются все-со-всеми и отправляют информацию только о своих каналах (линках).
На пальцах разница: в первых сосед говорит "я знаю где вот такие сети, присылай инфу мне, если что-то касается их". Сосед присылает и не разбирается ни в чем больше. Бывает, что происходят зацикливания, сломанный телефон и т.д.
Во вторых маршрутизаторы сообщают "у меня есть конкретно такая сеть, пропускная способность такая-то", они рассказывают только то, что они знают. В результате каждый маршрутизатор самостоятельно рассчитывает маршруты до каждой сети, он берет инфу с соседей только кто-что знает, а куда отправить он сам считает. Это более затратно по ПО, но более надежно. 

# Протокол RIP
Routing Information Protocol – дистанционно-векторный протокол прикладного уровня
(административное расстояние – 120). В качестве метрики используется количество хопов (промежуточных устройств). Максимальное количество хопов 15. Работает минимум на 3 таймерах:
1. Таймер регулярной рассылки (30 сек в RIP) – по истечению маршрутизатор кидает всем своим соседям update (табл. маршрут);
2. Таймер timeout (120 (180) сек в RIP) – запускается, когда запись появилась в таблице маршрутизации; сбрасывается (обновляется) при поступлении update, но если после конца таймера апдейт не пришел, запись становится предположительно недостижимой и получает бесконечную метрику;
3. Сборщик мусора (180 (240) сек) – запускается когда истекает таймаут. Если так и не пришли update с записью не пришел, то запись удаляется; маршрут обозначается недопустимым, когда метрика выставлена 16 (количество промежуточных устройств).

## RIP (1 версия)
![[Pasted image 20250411193647.png]]
- Команда определяет функционал (запрос/ответ) сообщений. Запрос -- запрос к соседу таблицы маршрутизации при появлении устройства в сети, чтобы не ждать, когда ему кинут регулярной рассылкой. Ответ -- либо регулярная рассылка, либо ответ на запрос. Если кидаете запрос -- кидается только первая строчка
- IP адресного пространства -- сообщение о том, что используется TCP/IP
- IP-адрес -- Destination Address
- Метрика -- значение метрики
На рисунке изображена одна запись таблицы маршрутизации (один маршрут), если их несколько снизу присоединяются еще таблицы. Всего в сообщении помещается максимум 25 таблиц. Это связано с ограничениями на канальном уровне (1500 байт), ограничение зависит от среды передачи данных.
Рассылается на широковещательный адрес каждые 30 секунд.

## RIPv2
1) RIPv2 отправляется на групповой адрес. 
2) Присутствует Next Hop, тот IP, с которого отправляется update (IP-адрес ближайшего интерфейса маршрутизатора, где находится данная сеть). (IP после via в таблице)
3) Поддерживается бесклассовая маршрутизация CIDR, то есть содержится маска
4) Добавляется тэг маршрута.
![[Pasted image 20250411194921.png]]
Если тэг внешнего маршрута, то метрика рассчитывается по сложной схеме.
Также записывается групповой адрес, на который отправляется сообщение.

# Петля маршрутизации
![[Pasted image 20250411195658.png]]
Снизу в столбцах таблицы маршрутизации для каждого роутера.
.1 -- последний октет
Пока что только назначили айпи и написал n sh.

Таблица маршрутизации для A (R1):
10.1.0.0/16 DC 0/0
10.2.0.0/16 DC 0/1
Таблица маршрутизации для B (R2):
10.2.0.0/16 DC 0/0
10.3.0.0/16 DC 0/1
Таблица маршрутизации для C (R3):
10.3.0.0/16 DC 0/0
10.4.0.0/16 DC 0/1

Эти записи подключаются автоматически. Первые две лабы работали без протоколов маршрутизации, поскольку был всего один маршрутизатор и все было подключено напрямую (DC).
Эти айпишники VLSM (CIDR), написано 16, а класс не B, а А => бесклассовая => RIPv2

![[Pasted image 20250411201214.png]]
Если 4 сеть отвалилась (появился крест, т.е. запись автоматически и моментально без таймеров пропадает в таблице), пусть у B таймер регулярной рассылки сработал быстрее чем у C, он сообщил C, что знает где 4 подсеть. На С появляется запись, что 4 подсеть пришла с 0 интерфейса, поставил метрику 2, поскольку у С метрика 1.

Пусть со стороны приходит на А письмо на 4 подсеть, она отправляет на В, В на С, С на В, В на С и так далее. Петля маршрутизации будет происходить до истечения TTL.

Существуют пять методов предотвращения петель маршрутизации

## Методы предотвращения петель
1. Расщепление горизонта: информация не отправляется назад источнику информации
2. Отравление маршрута: в этой ситуации когда четвертая подсеть на С отваливается, С в апдейт включает эту запись, но с бесконечной метрикой и сообщает тем самым В, что четвертая подсеть отвалилась.
3. Обратное отравление: отправит назад источнику информации запись с бесконечной метрикой.
4. Таймеры удержания: запускается на записи, когда удалится сеть. В течение работы этого таймера не принимается информация от данной сети с метрикой хуже, чем была.
5. Триггерные сообщения -- апдейты, которые рассылаются сразу по какому-либо изменению в сети (не дожидаясь таймера регулярной рассылки). Изменение в сети в данном случае удаление сети.
# Open Shortest Path First (OSPF)

Иерархический протокол (это означает, что он работает по зонам), является протоколом состояния канала. Это означает, что данный протокол подразумевает, что все маршрутизаторы сообщают всем маршрутизаторам информацию о своих каналах, каждый маршрутизатор в своей голове строит граф, который является топологией сети, вершины -- маршрутизаторы, ребра -- каналы связи с их характеристиками. Далее по алгоритму Дейкстры происходит поиск оптимального маршрута. В качестве метрики используется информация о пропускной способности $М = \frac{100Мбит}{проп.способность}$. Это бесклассовый протокол.

## Заголовок OSPF
<table>
  <tr>
    <th>Версия(0-7)</th>
    <th>Тип(8-15)</th>
    <th>Длина сообщения(16-32)</th>
  </tr>
  <tr>
    <td colspan="3">ID маршрута</td>
  </tr>
  <tr>
    <td colspan="3">ID области</td>
  </tr>
  <tr>
    <td>Контрольная сумма</td>
    <td colspan="2">Тип идентификации</td>
  </tr>
  <tr>
    <td colspan="3">Идентификация</td>
  </tr>
<tr>
    <td colspan="3">Идентификация</td>
  </tr>
</table>
Первая версия не используется давно, вторая для IPv4, третья для IPv6.
Тип -- определяет функционал сообщения:
1. Hello -- рассылается на регулярной основе. Каждые пять секунд маршрутизатор кидает это сообщение, что подтвердить что он еще живой. Если соседний маршрутизатор не получает, он выписывает текущий маршрутизатор из своей топологии в голове. Если меняем Hello-таймер, то меняем и принимающий таймер.
2. Data Base Description -- описание топологической базы данных. Эта база данных отправляется главным маршрутизатором новичку-маршрутизатору. 
3. Link State Request -- сообщение от "новичка", которое запрашивает базу данных. В каждой такой БД есть время жизни, когда время жизни подходит к окончанию делается Request, чтобы убедиться все ли так или что-то изменилось.
4. Link State Update -- ответ на Request либо сообщение (по принципу триггера) об изменение в сети.
5. Link State Acknowledgment -- "Спасибо, я получил", подтверждение о получении.
Все эти сообщения находятся внутри зоны.
Длина сообщения зависит от типа.
ID маршрутизатора выглядит как айпишник (точь-в-точь) нужен чтобы выбрать главный маршрутизатор и идентифицироваться в самом графе. Можно получить тремя способами:
	а) Задать руками;
	б) Маршрутизатор задаст сам: посмотрим на логический (виртуальный) интерфейс, выберет тот айпишник, который меньше всего (минимальный) и поставим как ID маршрутизатора.
	в) Если нет виртуальных интерфейсов, то возьмем физический интерфейс и возьмем минимальный айпи среди них.
На основе этих ID происходит выбор главного Designited Router (DR). Он будет отвечать на запросы о базе данных. Следующий маршрутизатор по возрастанию ID будет BDR (BackUp DR) -- тот, кто будет следующим DR автоматически, если что-то произойдет с основным.
ID области (зоны) -- ID той области, которой принадлежит данное сообщение. Нужно чтобы маршрутизаторы не перекидывали сообщения из своей зоны.

Три типа идентификации:
1. Отсутствие идентификации. Данное сообщение может прочитать любой маршрутизатор, у которого запущен процесс OSPF (из этой зоны)
2. Открытым текстом. На маршрутизаторе задается пароль, он помещается в поля идентификации, сообщение отправляется. При получении сообщения, маршрутизатор сравнивает свой пароль и пароль в сообщении, если совпало, имеет право обработать.
3. Открытый-зашифрованный. Шифруют MD5. Логика: на маршрутизаторе назначается пароль, в зашифрованном виде он помещается в сообщение, на приемной стороне маршрутизатор сравнивает свой пароль, если совпало -- обработали.
После заголовка идут полезные данные в зависимости от того, какой тип сообщения.
Групповой адрес, на который рассылается заголовок: 224.0.0.5. Административное расстояние 110.
```
While Card -- разрешено задавать единицы и нули, чтобы задать условие. Там где в маске нули важно совпасть с айпишником, там где единицы там пофиг что. Если надо задать диапазон нечетных айпишников, то его можно задать так: 192.168.1.1 0.0.0.254.
Просто какое-то отступление
```

# IGRP
## Interior Gateway Routing Protocol
Дистанционно-векторный протокол. Для метрики используют четыре параметра 
1. Пропускная способность (Bandwidth)
2. Загрузка (Load)
3. Задержка (Delay)
4. Надежность (Reliability)
$M = [K_{1}B + \frac{K_{2}B}{256-L} + K_{3}D] \frac{K_{5}}{R+K_{4}}$, где $K_{1,...,5}$ -- коэффициенты важности. 
K1 = K3 = 1, K2=K4=K5=0, значит
M = B + D

<table border="1" cellspacing="0" cellpadding="5" style="border-collapse: collapse; text-align: center;">
  <tr>
    <td colspan="1">4</td>
    <td colspan="1">8</td>
    <td colspan="2">16</td>
    <td colspan="2">23</td>
    <td colspan="2">31</td>
  </tr>
  <tr>
    <th colspan="1" style="text-align: center;">Version</th>
    <th colspan="1" style="text-align: center;">opcode</th>
    <th colspan="2" style="text-align: center;">Edition</th>
    <th colspan="2" style="text-align: center;">AS number</th>
    <th colspan="2" style="text-align: center;">&nbsp;</th>
  </tr>
  <tr>
    <td colspan="4" style="text-align: center;">Number as interior router</td>
    <td colspan="4" style="text-align: center;">Number as system router</td>
  </tr>
  <tr>
    <td colspan="4" style="text-align: center;">Number as exterior router</td>
    <td colspan="4" style="text-align: center;">Checksum</td>
  </tr>
  <tr>
    <td colspan="5" style="text-align: center;">ID address</td>
  </tr>
  <tr>
    <td colspan="5" style="text-align: center;">Delay</td>
  </tr>
  <tr>
    <td colspan="5" style="text-align: center;">Bandwidth</td>
  </tr>
  <tr>
    <td colspan="4" style="text-align: center;">MTV</td>
  </tr>
  <tr>
    <td colspan="2" style="text-align: center;">Reliability</td>
    <td colspan="2" style="text-align: center;">Load</td>
    <td colspan="2" style="text-align: center;">Hop Count</td>
  </tr>
</table>




Opcode -- операционный код, определяет функционал сообщения. Пакет корректировки и пакет запросов. Запрос по принципу "дай мне таблицу маршрутизации". В запросах только первая строка, остальное -- пакет корректировки.
Edition -- контроль версии. Edition изменяется каждый раз, когда происходит какое-то изменение в сети. По сути нужен для того, чтобы если на маршрутизатор пришло сообщение с номером edition меньше чем предыдущий полученный, значит пришло что-то старое. По сути Revision в VTP.
AS Number -- номер автономной системы (АС -- совокупность зон)